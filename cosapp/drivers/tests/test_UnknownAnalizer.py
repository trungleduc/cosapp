import pytest
import numpy as np
from contextlib import nullcontext as does_not_raise

from cosapp.drivers.utils import UnknownAnalyzer
from cosapp.base import System
from cosapp.core.numerics.basics import MathematicalProblem
from cosapp.utils.testing import get_args
from typing import Type


dummy_specs = dict(
    inwards=[
        get_args('x', 1.0),
        get_args('u', np.ones(3)),
    ],
    outwards=[
        get_args('y', 0.0),
        get_args('v', np.zeros(3)),
    ],
)


@pytest.fixture
def MockUpFactory(DummySystemFactory):
    def Factory(classname="MockUp", **options):
        """`options` includes equations, unknowns, targets, etc."""
        return DummySystemFactory(
            classname,
            **dummy_specs,
            **options,
        )
    return Factory


@pytest.fixture
def dummy(MockUpFactory):
    """Create simple system of type `Dummy`, generated by `MockUpFactory`.
    """
    Dummy = MockUpFactory(classname="Dummy")
    return Dummy('dummy')


@pytest.fixture
def CompositeFactory(MockUpFactory):
    """Composite system `top/mid/sub`, where `sub` is of type `MockUp`.
    """
    def Factory(**options):
        MockUp = MockUpFactory(**options)
        top = System('top')
        mid = System('mid')
        sub = mid.add_child(MockUp('sub'), pulling={'x': 'a', 'y': 'b', 'u': 'Um'})
        top.add_child(mid, pulling={'Um': 'U'})
        return top
    
    return Factory


@pytest.fixture
def top(CompositeFactory) -> System:
    """Composite system from `CompositeFactory`.
    """
    return CompositeFactory()


@pytest.fixture
def top_offdesign(CompositeFactory) -> System:
    """Composite system `top/mid/sub` from `CompositeFactory`,
    where `sub` has off-design unknowns and equations.
    """
    return CompositeFactory(
        unknowns=["x", "u"],
        equations=[
            "y == 0",
            "v == 0",
        ],
    )


@pytest.mark.parametrize("system, expected", [
    (None, does_not_raise()),
    (System('foo'), does_not_raise()),
    (0, pytest.raises(TypeError)),
    ('string', pytest.raises(TypeError)),
])
def test_UnknownAnalyzer__init__(system, expected):
    with expected:
        handler = UnknownAnalyzer(system)
        assert handler.system is system
        assert handler.data == dict()


def test_UnknownAnalyzer_input_mapping(dummy: System):
    """Test method `input_mapping`.
    """
    handler = UnknownAnalyzer(dummy)
    assert handler.system is dummy
    assert set(handler.input_mapping) == set(dummy.input_mapping)
    assert set(handler.input_mapping.values()) == set(dummy.input_mapping.values())
    assert set(handler.input_mapping) == {
        'x', 'inwards.x',
        'u', 'inwards.u',
    }


def test_UnknownAnalyzer_filter_problem_undefined(dummy):
    """Test method `filter_problem` with undefined system
    """
    handler = UnknownAnalyzer(None)
    assert handler.system is None

    problem = MathematicalProblem('problem', dummy)
    
    with pytest.raises(ValueError):
        handler.filter_problem(problem)


def test_UnknownAnalyzer_filter_problem_1(top: System):
    """Test method `filter_problem` with composite system `top`
    """
    handler = UnknownAnalyzer(top)
    assert handler.system is top

    # Create mathematical problem to be filtered
    problem = MathematicalProblem('problem', top)
    problem.add_unknown(['mid.sub.x', 'mid.sub.u'])
    problem.add_equation([
        'mid.b == 0',
        'mid.sub.y == 0',
    ])
    assert set(problem.unknowns) == {
        'mid.sub.x',
        'mid.sub.u',
    }
    assert set(problem.residues) == {
        'mid.b == 0',
        'mid.sub.y == 0',
    }

    filtered = handler.filter_problem(problem)
    assert set(filtered.unknowns) == {
        'U',
        'mid.a',
    }
    assert set(filtered.residues) == {
        'mid.b == 0',
        'mid.sub.y == 0',
    }


def test_UnknownAnalyzer_filter_problem_2(top_offdesign: System):
    """Test method `filter_problem` with composite system `top`
    """
    top = top_offdesign  # alias
    handler = UnknownAnalyzer(top)
    assert handler.system is top

    problem = top.get_unsolved_problem()
    filtered = handler.filter_problem(problem)
    assert set(filtered.unknowns) == {
        'U',
        'mid.a',
    }
    assert set(filtered.residues) == {
        'mid.sub: y == 0',
        'mid.sub: v == 0',
    }
